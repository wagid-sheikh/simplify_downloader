from __future__ import annotations

import argparse
import asyncio
import os
import smtplib
from dataclasses import dataclass
from datetime import date, datetime, timedelta
from email.message import EmailMessage
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple

from dashboard_downloader.json_logger import JsonLogger, get_logger, log_event, new_run_id
from dashboard_downloader.report_generator import (
    StoreReportDataNotFound,
    build_store_context,
    render_store_report_pdf,
)

DEFAULT_TEMPLATE_DIR = Path(__file__).with_name("templates")
DEFAULT_REPORTS_ROOT = Path("reports")


@dataclass
class EmailSettings:
    to: List[str]
    cc: List[str]
    sender: str
    subject_template: str
    host: str
    port: int
    username: str | None
    password: str | None
    use_tls: bool


def _parse_store_list(raw: str | None) -> List[str]:
    if not raw:
        return []
    return [token.strip().upper() for token in raw.split(",") if token.strip()]


def _resolve_report_date(arg_value: str | None) -> date:
    if arg_value:
        return date.fromisoformat(arg_value)
    return date.today() - timedelta(days=1)


def _parse_address_list(raw: str | None) -> List[str]:
    if not raw:
        return []
    return [token.strip() for token in raw.split(",") if token.strip()]


def _load_email_settings() -> EmailSettings | None:
    to = _parse_address_list(os.getenv("REPORT_EMAIL_TO"))
    if not to:
        return None
    host = os.getenv("REPORT_EMAIL_SMTP_HOST")
    port_raw = os.getenv("REPORT_EMAIL_SMTP_PORT")
    if not host or not port_raw:
        return None
    cc = _parse_address_list(os.getenv("REPORT_EMAIL_CC"))
    sender = os.getenv("REPORT_EMAIL_FROM", "reports@tsv.com")
    subject_template = os.getenv("REPORT_EMAIL_SUBJECT_TEMPLATE", "[Store Reports] {{report_date}}").strip() or "[Store Reports] {{report_date}}"
    username = os.getenv("REPORT_EMAIL_SMTP_USERNAME")
    password = os.getenv("REPORT_EMAIL_SMTP_PASSWORD")
    use_tls = os.getenv("REPORT_EMAIL_USE_TLS", "true").lower() == "true"
    return EmailSettings(
        to=to,
        cc=cc,
        sender=sender,
        subject_template=subject_template,
        host=host,
        port=int(port_raw),
        username=username,
        password=password,
        use_tls=use_tls,
    )


def _render_subject(template: str, report_date: date) -> str:
    return template.replace("{{report_date}}", report_date.isoformat())


def _build_email_message(
    settings: EmailSettings,
    report_date: date,
    pdf_records: Sequence[Tuple[str, Path]],
) -> EmailMessage:
    message = EmailMessage()
    message["Subject"] = _render_subject(settings.subject_template, report_date)
    message["From"] = settings.sender
    message["To"] = ", ".join(settings.to)
    if settings.cc:
        message["Cc"] = ", ".join(settings.cc)
    body_lines = [
        f"Daily store health reports for {report_date.isoformat()}.",
        "",
        "Stores:",
    ]
    body_lines.extend(f"- {store_code}" for store_code, _ in pdf_records)
    body_lines.extend(["", "Generated by TSV Simplify Downloader."])
    message.set_content("\n".join(body_lines))

    for store_code, pdf_path in pdf_records:
        attachment_name = f"{store_code}.pdf"
        data = pdf_path.read_bytes()
        message.add_attachment(
            data,
            maintype="application",
            subtype="pdf",
            filename=attachment_name,
        )
    return message


def _send_email(settings: EmailSettings, message: EmailMessage) -> None:
    if settings.use_tls:
        with smtplib.SMTP(settings.host, settings.port) as client:
            client.starttls()
            if settings.username and settings.password:
                client.login(settings.username, settings.password)
            client.send_message(message)
    else:
        with smtplib.SMTP(settings.host, settings.port) as client:
            if settings.username and settings.password:
                client.login(settings.username, settings.password)
            client.send_message(message)


def _log_skip(logger: JsonLogger) -> None:
    log_event(
        logger=logger,
        phase="report",
        status="info",
        message="no REPORT_STORES_LIST configured, skipping report generation",
    )


def _parse_args(argv: Iterable[str] | None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate per-store daily PDF reports")
    parser.add_argument("--report-date", dest="report_date", help="Report date (YYYY-MM-DD)")
    parser.add_argument("--run-id", dest="run_id", help="Override run id", default=None)
    parser.add_argument(
        "--template-path",
        dest="template_path",
        default=str(DEFAULT_TEMPLATE_DIR),
        help="Directory containing store_report.html",
    )
    parser.add_argument(
        "--reports-dir",
        dest="reports_dir",
        default=str(DEFAULT_REPORTS_ROOT),
        help="Directory to write generated PDFs",
    )
    return parser.parse_args(list(argv) if argv is not None else None)


async def _send_email_if_configured(
    logger: JsonLogger,
    report_date: date,
    pdf_records: Sequence[Tuple[str, Path]],
) -> None:
    if not pdf_records:
        log_event(
            logger=logger,
            phase="report_email",
            status="info",
            message="no reports generated, skipping email",
        )
        return

    settings = _load_email_settings()
    if not settings:
        log_event(
            logger=logger,
            phase="report_email",
            status="info",
            message="report_email: disabled or not configured, skipping send",
        )
        return

    message = _build_email_message(settings, report_date, pdf_records)
    try:
        await asyncio.to_thread(_send_email, settings, message)
    except Exception as exc:  # pragma: no cover - network errors
        log_event(
            logger=logger,
            phase="report_email",
            status="error",
            message="report email failed",
            extras={"error": str(exc)},
        )
        return

    log_event(
        logger=logger,
        phase="report_email",
        status="ok",
        message="report email sent",
        extras={
            "report_date": report_date.isoformat(),
            "store_codes": [code for code, _ in pdf_records],
            "to": settings.to,
        },
    )


async def _generate_reports(
    store_codes: Sequence[str],
    report_date: date,
    *,
    logger: JsonLogger,
    run_id: str,
    database_url: str,
    template_path: Path,
    reports_root: Path,
) -> List[Tuple[str, Path]]:
    generated: List[Tuple[str, Path]] = []
    for code in store_codes:
        log_event(
            logger=logger,
            phase="report",
            status="info",
            message="report generation start",
            store_code=code,
            extras={"report_date": report_date.isoformat(), "run_id": run_id},
        )
        try:
            context = await build_store_context(
                store_code=code,
                report_date=report_date,
                run_id=run_id,
                database_url=database_url,
            )
        except StoreReportDataNotFound as exc:
            log_event(
                logger=logger,
                phase="report",
                status="warn",
                message="no data available for report date",
                store_code=code,
                extras={"report_date": report_date.isoformat(), "error": str(exc)},
            )
            continue
        except Exception as exc:  # pragma: no cover - safeguard
            log_event(
                logger=logger,
                phase="report",
                status="error",
                message="failed to build report context",
                store_code=code,
                extras={"report_date": report_date.isoformat(), "error": str(exc)},
            )
            continue

        output_path = reports_root / report_date.isoformat() / f"{code}.pdf"
        try:
            await render_store_report_pdf(
                store_context=context,
                template_path=template_path,
                output_path=output_path,
            )
        except Exception as exc:  # pragma: no cover - pdf failures
            log_event(
                logger=logger,
                phase="report",
                status="error",
                message="failed to render pdf",
                store_code=code,
                extras={"report_date": report_date.isoformat(), "error": str(exc), "path": str(output_path)},
            )
            continue

        generated.append((code, output_path))
        log_event(
            logger=logger,
            phase="report",
            status="ok",
            message="report pdf generated",
            store_code=code,
            extras={"report_date": report_date.isoformat(), "path": str(output_path)},
        )
    return generated


async def main(argv: Iterable[str] | None = None) -> int:
    args = _parse_args(argv)
    run_id = args.run_id or new_run_id()
    logger = get_logger(run_id=run_id)

    try:
        report_date = _resolve_report_date(args.report_date)
    except ValueError:
        log_event(
            logger=logger,
            phase="report",
            status="error",
            message="invalid --report-date supplied",
            extras={"value": args.report_date},
        )
        logger.close()
        return 1

    store_codes = _parse_store_list(os.getenv("REPORT_STORES_LIST"))
    if not store_codes:
        _log_skip(logger)
        logger.close()
        return 0

    database_url = os.getenv("DATABASE_URL")
    if not database_url:
        log_event(
            logger=logger,
            phase="report",
            status="error",
            message="DATABASE_URL is required for report generation",
        )
        logger.close()
        return 1

    template_path = Path(args.template_path)
    reports_root = Path(args.reports_dir)

    pdf_records = await _generate_reports(
        store_codes,
        report_date,
        logger=logger,
        run_id=run_id,
        database_url=database_url,
        template_path=template_path,
        reports_root=reports_root,
    )

    await _send_email_if_configured(logger, report_date, pdf_records)
    logger.close()
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(asyncio.run(main()))
